
   // Stuff defined in this file:
   //  . the data structures that store the configuration of
   //    the stack of panels
   //  . the main game routine
   //    (rising, timers, falling, cursor movement, swapping, landing)
   //  . the matches-checking routine




   // The stack of panels.
int P1StackPanels[96];
   // Twelve rows of 8 ints each, the first 6 representing
   // the panels on that row.
   // A panel's color can be retrieved using P1Stack[row<<3+col]



   // Each space on the stack of panels has a timer.
int P1StackTimers[96];
   // A panel's timer indicates for how many more frames it will:
   //  . be swapping
   //  . sit in the MATCHED state before being set POPPING
   //  . sit in the POPPING state before actually being POPPED
   //  . sit and be POPPED before disappearing for good
   //  . hover before FALLING
   // depending on which one of these flags is set on the panel.



   // Each space on the stack of panels has flags
   // that define the state it's in.
int P1StackFlags[96];
   
#define   FLAG_SWAPPING         1   // bit 0
#define   FLAG_FROMLEFT         2   // bit 1
   // Bit 0 is set if the panel is swapping.
   // The panel's timer then counts down from 3 to 0,
   // causing the swap to end 3 frames later.
   // The timer is also used to offset the panel's
   // position on the screen.
   //  Bit 1 indicates from which direction the panel
   //  is swapping:
   //   0 - from right
   //   1 - from left
#define   FLAG_DONTSWAP         4   // bit 2
   // In some cases a swapping panel shouldn't be allowed to swap
   // again until it's done with the swapping it's doing already.
   // In these cases bit 2, FLAG_DONTSWAP, should be set.

#define   FLAG_MATCHED          8   // bit 3
   // This flag is set when a panel's matched, then its timer counts
   // down until it reaches 0, at which time it will become:
#define   FLAG_POPPING         16   // bit 4
   // Popping.  All the panels in a match become popping at once,
   // but their timers for remaining in this state will be higher
   // depending on their place in the match (FLAG_MATCHINDEX).
#define   FLAG_POPPED          32   // bit 5
   // This flag indicates that panel has popped, but it's still
   // there until the last panel in the match pops.  When
   // its timer reaches 0 the panel is GONE!

#define   FLAG_HOVERING        64   // bit 6
   // This panel is floating and cannot be touched until
   // its timer reaches 0 and it begins to fall.
#define   FLAG_FALLING        128   // bit 7

#define   FLAG_CHAINING       256   // bit 8
   // A match made with a chain panel is a chain match...
   // Chain panels are de-flagged during the match-checking
   // routine, if they are eligible for a match but didn't make
   // one, and also are not sitting on top of a hovering or
   // swapping panel.  The chain flag must remain set on the panel
   // until it pops.

#define   FLAG_DIMMED         512   // bit 9
   // This panel is on the bottom row and isn't in play.
#define   FLAG_LANDING       1024   // bit 10
   // A panel that landed just recently.  This flag is set
   // so that the timer can be used to index the correct
   // frame to be drawn for the panel (the 'bounce' effect).
   // These next definitions exclude panels in certain states
   // from being acted upon in certain ways.
 // Bits 11-31 are reserved for possible future needs

 #define   EXCLUDE_HOVER       632
    // If a panel is matched, popping, popped, hovering,
    // or falling it won't get set hovering.
 #define   EXCLUDE_MATCH       761
    // If a panel is swapping, matched, popping, popped, hovering,
    // dimmed, or falling it isn't eligible for a match.
 #define   EXCLUDE_SWAP        636  
    // A panel is untouchable when matched, popping, popped, hovering,
    // dimmed, or is a swapping empty space below a panel (DONTSWAP).


   // And finally, each panel has a couple tags.
   // Unlike the timers and flags, they don't need to be cleared
   // when their data is no longer valid, because they should
   // only be checked when the data is surely valid.
int P1StackTags[96];
#define   TAG_COMBOINDEX        127   // bits 0-6
#define   TAG_COMBOSIZE       16256   // bits 7-13
#define   TAG_CHAININDEX 4294950912   // bits 14-31 (hahaha)




   // Stack displacement.
int P1StackDisplacement;
   // This variable indicates how far below the top of the play
   // area the top row of panels actually is.
   // This variable being decremented causes the stack to rise.
   // During the automatic rising routine, if this variable is 0,
   // it's reset to 15, all the panels are moved up one row,
   // and a new row is generated at the bottom.
   // Only when the displacement is 0 are all 12 rows "in play."

   int DoMatchesCheck;
      // if this gets set non-zero a matches-check will occur for this
      // frame.

int P1DangerCol[6];  // set 1 if this column is near the top
int P1DangerTimer;   // decided bounce frame when in danger


int P1DifficultyLV;
#define VEASY  0
#define EASY   1
#define NORMAL 2
#define HARD   3
#define VHARD  4


int P1SpeedLV;   // The player's speed level decides the amount of time
                 // the stack takes to rise automatically
int P1RiseTimer;   // When this value reaches 0, the stack will rise a pixel
int P1RiseLock;   // If the stack is rise locked, it won't rise until it is
                  // unlocked.
int P1HasRisen;   // set once the stack rises once during the game


int P1StopTime;
int P1StopTimeTimer;
int StopTime_Combo[2][5];
int StopTime_Chain[2][5];



int GameTime;
int GameTimeMode;
int GameTimeTimer;
#define TIME_ELAPSED 1
#define TIME_REMAINING 2



int ScoreMode;
#define SCOREMODE_TA      1
#define SCOREMODE_PDP64   2

int P1Score;          // der skore
int P1ChainCounter;   // how high is the current chain?



   // The following variables keep track of stuff:
int bottomrow;   // row number of the bottom row that's "in play"
int PanelsInTopRow;  // boolean, panels in the top row (danger)
int PanelsInSecondRow; // changes music state


int Count_ActivePanels;
int Count_ChainPanels;



   // These change depending on the difficulty and speed levels:
int FRAMECOUNT_HOVER;
int FRAMECOUNT_MATCH;
int FRAMECOUNT_FLASH;
int FRAMECOUNT_POP;
int FRAMECOUNT_RISE;





   // Player input stuff:
int P1ManualRaise;   // set until raising is completed
int P1ManualRaiseYet;  // if not set, no actual raising's been done yet
                       // since manual raise button was pressed
int P1PreventManualRaise;
int P1Swap1;   // attempt to initiate a swap on this frame
int P1Swap2;

int P1CurWaitTime;   // number of ticks to wait before the cursor begins
                     // to move quickly... it's based on P1CurSensitivity
int P1CurTimer;   // number of ticks for which a new direction's been pressed
int P1CurDir;     // the direction pressed
int P1CurRow;  // the row the cursor's on
int P1CurCol;  // the column the left half of the cursor's on

#define DIR_UP    1
#define DIR_DOWN  2
#define DIR_LEFT  3
#define DIR_RIGHT 4

int P1CurMoveAloud;  // this is set if the cursor movement sound should be played


 // score lookup tables
int Score_Combo_PdP64[40];
int Score_Combo_TA[31];
int Score_Chain_TA[14];


int P1GameOver;



   // The engine routine.
void PdP()
{
      // The main game routine has five phases:
      //  1. Decrement timers, act on expired ones
      //  2. Move falling panels down a row
      //  3. Do things according to player input
      //  4. Make falling panels land
      //  5. Possibly do a matches-check

      // During these phases the entire StackPanels will be examined
      // several times, from first to last (or last to first).
      // Here are defined the necessary counters for iterating through
      // the StackPanels and StackTimers:
   int row, col;   // used for iterating through the StackPanels
   int panel;      // used when row and col are avoidable
   int counter;    // an extra general-purpose counter

      // other general-purpose things:
   int whatever, something, somethingelse;


   if(P1StopTime)
   {
      P1StopTimeTimer--;
      if(!P1StopTimeTimer)
      {
         P1StopTime--;
         if(P1StopTime) P1StopTimeTimer=60;
      }
   }


   if(P1StackDisplacement) bottomrow=10;
   else bottomrow=11;   // the 12th row (row 11) is only "in play"
                        // when the stack displacement is 0
                        // and there are panels in the top row

      // count the number of panels in the top row (danger)
   PanelsInTopRow=0;   
   for(panel=0;panel<6;panel++)
   {
      if(P1StackPanels[panel])
      {
         PanelsInTopRow=1;
         P1DangerCol[panel]=1;
      }
      else P1DangerCol[panel]=0;
   }
   if(PanelsInTopRow)
   {
      if(!P1StopTime)
      {
         P1DangerTimer--;
            if(P1DangerTimer<0) P1DangerTimer=17;
      }
   }

   PanelsInSecondRow=0;
   for(panel=8;panel<14;panel++)
   {
      if(P1StackPanels[panel])
         PanelsInSecondRow=1;
   }
   if(PanelsInSecondRow)
   {
      if(GameMusicState=MUSIC_NORMAL)
      {
         GameMusicState=MUSIC_DANGER;
         GameMusicStateChange=1;
      }
   }
   else
   {
      if(GameMusicState=MUSIC_DANGER)
      {
         GameMusicState=MUSIC_NORMAL;
         GameMusicStateChange=1;
      }
   }

   if(!P1StackDisplacement && P1HasRisen)
   {
      if(!PanelsInTopRow)
      {
         NewRow();
      }
   }

   if( Count_ActivePanels ) P1RiseLock=1;
   else P1RiseLock=0;


   if(!P1StackDisplacement && PanelsInTopRow && !P1RiseLock && !P1StopTime)
      P1GameOver=1;

      // Phase 0 //////////////////////////////////////////////////////////////
      // Stack automatic rising


   if(P1SpeedLV && !P1ManualRaise)   // only rise if speed LV is non-zero
   {
      if(!P1StopTime && !P1RiseLock)
      {
         P1RiseTimer--;
         if(!P1RiseTimer)   // try to rise
         {
            if(!P1StackDisplacement)
            {
               if(P1HasRisen || PanelsInTopRow)
               {
                  //P1GameOver=1;
               }
               else
               {
                  NewRow();
                  P1StackDisplacement=15;
                  P1HasRisen=1;
               }
            }
            else
            {
               P1StackDisplacement--;
               if(!P1StackDisplacement)
               {
                  P1PreventManualRaise=0;
                  if(PanelsInTopRow)
                  {
                     for(panel=88;panel<94;panel++)
                        if(P1StackFlags[panel] & FLAG_DIMMED)
                           P1StackFlags[panel]-=FLAG_DIMMED;                  
                     bottomrow=11;
                  }
                  else
                  {
                     NewRow();
                  }
               }
            }
            P1RiseTimer=FRAMECOUNT_RISE;
         }
      }
   }



      // Phase 1 . ///////////////////////////////////////////////////////
      //  Falling

   for(row=bottomrow;row>=0;row--)
   {
      panel=row<<3;
      for(col=0;col<6;col++)
      {
         if(P1StackFlags[panel] & FLAG_FALLING)
         {
               // if there's no panel below a falling panel,
               // it must fall one row.
               // I'm gonna assume there's no panel below,
               // because the falling panel should've landed on
               // it during the last frame if there was.
            P1StackPanels[panel+8]=P1StackPanels[panel];
            P1StackFlags[panel+8]=P1StackFlags[panel];
            P1StackTimers[panel+8]=0;
            P1StackPanels[panel]=0;
            P1StackFlags[panel]=0;
               // the timer can be left behind because it should be 0.
               // the tags can be left behind because they're not important
               // until a panel is stuck in position.
         }
         panel++;
      }
   }



      // Phase 2. /////////////////////////////////////////////////////////////
      //  Timer-expiring actions


   for(row=bottomrow;row>=0;row--)
   {
      panel=row<<3;
      for(col=0;col<6;col++)
      {
            // first of all, we do Nothin' if we're not even looking
            // at a space with any flags.
         if(P1StackFlags[panel])
         {
            if(P1StackTimers[panel])
            {
               P1StackTimers[panel]--;
               if(!P1StackTimers[panel])
               {
                  if(P1StackFlags[panel] & FLAG_SWAPPING)
                  {
                        // a swap has completed here.
                     P1StackFlags[panel]-=FLAG_SWAPPING;
                     if(P1StackFlags[panel] & FLAG_DONTSWAP)
                        P1StackFlags[panel]-=FLAG_DONTSWAP;
                     if(P1StackFlags[panel] & FLAG_FROMLEFT)
                     {
                        P1StackFlags[panel]-=FLAG_FROMLEFT;
                        something=1;
                     }  else something=0;
                     // Now there are a few cases where some hovering must
                     // be done.
                     if(P1StackPanels[panel])
                     {
                        if(row!=bottomrow)
                        {
                           if(!P1StackPanels[panel+8])
                           {
                              SetHoverers2(panel,FRAMECOUNT_HOVER,0);
                                 // if there is no panel beneath this panel
                                 // it will begin to hover.
              // CRAZY BUG EMULATION:
              // the space it was swapping from hovers too
                              if(something)
                              {
                                 if(P1StackFlags[panel-1] & FLAG_FALLING)
                                    SetHoverers2(panel-1,FRAMECOUNT_HOVER,0);
                              }
                              else
                              {
                                 if(P1StackFlags[panel+1] & FLAG_FALLING)
                                    SetHoverers(panel+1,FRAMECOUNT_HOVER+1,0);
                              }

                           }
                           else
                           {
                                 // swap may have landed on a hover
                              if(P1StackFlags[panel+8] & FLAG_HOVERING)
                                 SetHoverers2(panel,FRAMECOUNT_HOVER,0);
                           }
                        }
                     }
                     else
                     {
                           // an empty space finished swapping...
                           // panels above it hover
                        SetHoverers(panel-8,FRAMECOUNT_HOVER+1,0);
                     }
                     // swap completed, a matches-check will occur this frame.
                     DoMatchesCheck=1;
                  }
                  else
                  {
                     if(P1StackFlags[panel] & FLAG_HOVERING)
                     {
                           // This panel is no longer hovering.
                           // it will now fall without sitting around
                           // for any longer!
                        P1StackFlags[panel]-=FLAG_HOVERING;
                        if(P1StackPanels[panel+8])
                        {
                           P1StackFlags[panel]=P1StackFlags[panel] | FLAG_LANDING;
                           P1StackTimers[panel]=12;
                           DoMatchesCheck=1;
                        }
                        else
                        {
                           P1StackFlags[panel]+=FLAG_FALLING;
                           P1StackPanels[panel+8]=P1StackPanels[panel];
                           P1StackFlags[panel+8]=P1StackFlags[panel];
                           P1StackTimers[panel+8]=0;
                           P1StackPanels[panel]=0;
                           P1StackFlags[panel]=0;
                        }
                     }
                     else
                     {
                        if(P1StackFlags[panel] & FLAG_LANDING)
                           P1StackFlags[panel]-=FLAG_LANDING;
                        else
                        {
                           if(P1StackFlags[panel] & FLAG_MATCHED)
                           {
                              P1StackFlags[panel]-=FLAG_MATCHED;
                                 // This panel's match just finished the whole
                                 // flashing and looking distressed thing.
                                 // It is given a pop time based on its place
                                 // in the match.
                              P1StackFlags[panel]+=FLAG_POPPING;
                              something=P1StackTags[panel] & TAG_COMBOINDEX;
                              P1StackTimers[panel]=something*FRAMECOUNT_POP;
                           }
                           else
                           {
                              if(P1StackFlags[panel] & FLAG_POPPING)
                              {
                                 P1Score+=10;
                                 P1ScoreRender=1;
                                    // this panel just popped
                                    // Now it's invisible, but sits and waits
                                    // for the last panel in the combo to pop
                                    // before actually being removed.
                                 something=P1StackTags[panel] & TAG_COMBOSIZE;
                                 something=something>>7;
                                 whatever=P1StackTags[panel] & TAG_COMBOINDEX;
                                    // If it is the last panel to pop,
                                    // it should be removed immediately!
                                 if(something==whatever) //size==index
                                 {
                                    P1StackPanels[panel]=0;
                                    if(P1StackFlags[panel] & FLAG_CHAINING)
                                       Count_ChainPanels--;
                                    P1StackFlags[panel]=0;
                                    SetHoverers(panel-8,FRAMECOUNT_HOVER+1,FLAG_CHAINING);
                                 }
                                 else
                                 {
                                    P1StackFlags[panel]-=FLAG_POPPING;
                                    P1StackFlags[panel]+=FLAG_POPPED;
                                    P1StackTimers[panel]
                                       =(something-whatever)*FRAMECOUNT_POP;
                                 }
                                 something=P1StackTags[panel] & TAG_CHAININDEX;
                                 something=something>>14;
                                 if(!something) something=1;
                                 SFX_Pop_Play[0]=something;
                                 SFX_Pop_Play[1]=whatever;
                              }
                              else
                              {
                                 if(P1StackFlags[panel] & FLAG_POPPED)
                                 {
                                       // It's time for this panel
                                       // to be gone forever.
                                    P1StackPanels[panel]=0;
                                    if(P1StackFlags[panel] & FLAG_CHAINING)
                                       Count_ChainPanels--;
                                    P1StackFlags[panel]=0;
                                       // Any panels sitting on top of it
                                       // hover and are flagged as CHAINING
                                    SetHoverers(panel-8,FRAMECOUNT_HOVER+1,FLAG_CHAINING);
                                 }
                                 else
                                 {
                                    // what the heck.
                                    // if a timer runs out and the routine can't
                                    // figure out what flag it is, tell brandon.
                                    ShutDown(str(P1StackFlags[panel])+". What the heck"
                                    +" flag is "+str(P1StackFlags[panel])+"."
                                    +" This timer for a panel on row "+str(row)
                                    +" column "+str(col)+" expired and I haven't"
                                    +" the foggiest what to do with it...");
                                 }
                              }
                           }
                        }
                     }
                  }

                  // the timer-expiring action has completed
               }
            }
         }
         panel++;
      }
   }

      // Phase 3. /////////////////////////////////////////////////////////////
      //  Actions performed according to player input

                                                     // CURSOR MOVEMENT
      P1CurMoveAloud=0;
      something=0; whatever=0;
      if(!P1CurTimer) something=1;
      if(P1CurTimer==P1CurWaitTime) whatever=1;
      if(something || whatever)
      {
         if(P1CurDir==DIR_UP)
         {  if(P1CurRow>0)
            {  P1CurRow--;
               P1CurMoveAloud=1;
            }
         } else
         {  if(P1CurDir==DIR_DOWN)
            {  if(P1CurRow<bottomrow)
               {  P1CurRow++;
                  P1CurMoveAloud=1;
               }
            } else
            {  if(P1CurDir==DIR_LEFT)
               {  if(P1CurCol>0)
                  {  P1CurCol--;
                     P1CurMoveAloud=1;
                  }
               } else
               { if(P1CurDir==DIR_RIGHT)
                 {  if(P1CurCol<4)
                    {  P1CurCol++;
                       P1CurMoveAloud=1;
                    }
                 }
               }
            }
         }
      }
      if(!whatever)
      {
         P1CurTimer++;
         if(P1CurMoveAloud && something) SFX_P1Cursor_Play=1;
      }

                                                     // SWAPPING
   if(P1Swap1 || P1Swap2)
   {
      panel=(P1CurRow<<3)+P1CurCol;

         // in order for a swap to occur, one of the two panels in
         // the cursor must not be a non-panel.
      if(P1StackPanels[panel] || P1StackPanels[panel+1])
      {
            // also, both spaces must be swappable.
         something=P1StackFlags[panel] & EXCLUDE_SWAP;
         whatever=P1StackFlags[panel+1] & EXCLUDE_SWAP;
         if(!something && !whatever)
         {
            something=0;
            whatever=0;
            if(P1CurRow>0)
            {
               something=P1StackFlags[panel-8] & FLAG_HOVERING;
               whatever=P1StackFlags[panel-7] & FLAG_HOVERING;
            }
            if(!something && !whatever)
            {
               something=P1StackPanels[panel];
               P1StackPanels[panel]=P1StackPanels[panel+1];
               P1StackPanels[panel+1]=something;

               something=P1StackFlags[panel] & FLAG_CHAINING;
               whatever=P1StackFlags[panel+1] & FLAG_CHAINING;
               P1StackFlags[panel]=FLAG_SWAPPING | whatever;
               P1StackFlags[panel+1]=FLAG_SWAPPING | something | FLAG_FROMLEFT;

               P1StackTimers[panel]=3;
               P1StackTimers[panel+1]=3;

               SFX_Swap_Play=1;

               if(P1CurRow!=bottomrow)
               {
                  something=0;
                  if(!P1StackPanels[panel+8]) something=1;
                  else 
                  { if(P1StackFlags[panel+8] & FLAG_FALLING) something=1; }
                  if(P1StackPanels[panel] && something)
                     P1StackFlags[panel]+=FLAG_DONTSWAP;
                  something=0;
                  if(!P1StackPanels[panel+9]) something=1;
                  else
                  { if(P1StackFlags[panel+9] & FLAG_FALLING) something=1; }
                  if(P1StackPanels[panel+1] && something)
                     P1StackFlags[panel+1]+=FLAG_DONTSWAP;
               }

               if(P1CurRow>0)
               {
                  if(!P1StackPanels[panel])
                  {  if(P1StackPanels[panel-8])
                        P1StackFlags[panel]+=FLAG_DONTSWAP;
                  }
                  if(!P1StackPanels[panel+1])
                  {  if(P1StackPanels[panel-7])
                        P1StackFlags[panel+1]+=FLAG_DONTSWAP;
                  }
               }
            }
         }
      }
      P1Swap1=0;
      P1Swap2=0;
   }


 
                                               // MANUAL STACK RAISING
   if(P1ManualRaise)
   {
      if(!P1RiseLock)
      {
         if(!P1StackDisplacement)
         {
            if(P1HasRisen)
            {
               if(PanelsInTopRow)
               {
                  P1GameOver=1;
               }
            }
            else
            {
               NewRow();
               P1StackDisplacement=15;
               P1HasRisen=1;
            }
         }
         else
         {
            P1HasRisen=1;
            P1StackDisplacement--;
            if(P1StackDisplacement==1)
            {
               P1ManualRaise=0;
               P1RiseTimer=1;
               if(!P1PreventManualRaise){P1Score++;P1ScoreRender=1;}
               P1PreventManualRaise=1;
            }
         }
         if(!P1ManualRaiseYet) P1ManualRaiseYet=1;  //ehhhh
         P1StopTime=0;
         P1StopTimeTimer=0;
      }
      else
       if(!P1ManualRaiseYet) P1ManualRaise=0;
       // if the stack is rise locked when you press the raise button,
       // the raising is cancelled
   }



      // Phase 4. /////////////////////////////////////////////////////////////
      //  Now falling panels will land if they have something to land on that
      //  isn't falling as well.

   for(row=bottomrow;row>=0;row--)
   {
      panel=row<<3;
      for(col=0;col<6;col++)
      {
         if(P1StackFlags[panel] & FLAG_FALLING)
         {
               // if it's on the bottom row, it should surely land
            if(row==bottomrow)
            {
               P1StackFlags[panel]-=FLAG_FALLING;
               P1StackFlags[panel]=P1StackFlags[panel] | FLAG_LANDING;
               P1StackTimers[panel]=12;
               DoMatchesCheck=1;
               SFX_Land_Play=1;
            }
            else
            {
               if(P1StackPanels[panel+8])
               {
                  // if there's a panel below, this panel's gonna land
                  // unless the panel below is falling.
                  something=P1StackFlags[panel+8] & FLAG_FALLING;
                  if(!something)
                  {
                     P1StackFlags[panel]-=FLAG_FALLING;

                        // if it lands on a hovering panel, it inherits
                        // that panel's hover time.
                     something=P1StackFlags[panel+8] & FLAG_HOVERING;
                     if(something)
                     {
                        SetHoverers(panel,P1StackTimers[panel+8],0);
                     }
                     else
                     {
                        P1StackFlags[panel]=P1StackFlags[panel] | FLAG_LANDING;
                        P1StackTimers[panel]=12;
                     }
                     DoMatchesCheck=1;
                     SFX_Land_Play=1;
                  }
               }
            }
         }
         panel++;
      }
   }
 
      // Phase 5. /////////////////////////////////////////////////////////////
      // If a swap completed, one or more panels landed, or a new row was
      // generated during this tick, a matches-check is done.
   if(DoMatchesCheck) CheckMatches();


   // if at the end of the routine there are no chain panels, the chain ends.
   if(P1ChainCounter)
   {
      if(!Count_ChainPanels)
      {
         P1ChainCounter=0;

      }
   }

   if(P1Score>99999) P1Score=99999;


   GameTimeTimer--;
   if(!GameTimeTimer)
   {
      GameTimeTimer=60;
      Switch(GameTimeMode)
      {
         Case TIME_REMAINING:
            GameTime--;
            if(GameTime<0) GameTime=0;

            if(!GameTime) SFX_Bell_Play=25;
            else if(GameTime<15) SFX_Bell_Play=24;

         Case TIME_ELAPSED:
            GameTime++;
            if(GameTime>359999) GameTime=359999;
      }
      GameTimeRender=1;
   }

}


   ////////////////////////////////////////////////////////////////////////////
   // The matches-checking routine.

   // This array is used to remember which panels were matched.
int MatchedPanels[96];

void CheckMatches()
{
   int row, col, panel,count,oldpanel;
   int ischain;
   int firstpanelrow, firstpanelcol;
   int comboindex, combosize;
   int something, whatever;

   for(panel=0;panel<96;panel++) MatchedPanels[panel]=0;

                                                 // check vertical matches
   count=0;
   for(col=0;col<6;col++)
   {
      panel=col;
      oldpanel=0;
      for(row=0;row<bottomrow+1;row++)
      {
         something=P1StackFlags[panel] & EXCLUDE_MATCH;
         if(P1StackPanels[panel] && !something)
         {
            if(!count) count=1;
            else
            {
               if((P1StackPanels[panel])==(oldpanel))
               {
                  count++;
                  if(count>2)
                  {
                     if(!MatchedPanels[panel])
                     {
                        MatchedPanels[panel]=1;
                        if(P1StackFlags[panel] & FLAG_CHAINING)
                           ischain=1;
                        combosize++;
                     }
                     if(count==3)
                     {
                        if(!MatchedPanels[panel-8])
                        {
                           MatchedPanels[panel-8]=1;
                           if(P1StackFlags[panel-8] & FLAG_CHAINING)
                              ischain=1;
                           combosize++;
                        }
                        if(!MatchedPanels[panel-16])
                        {
                           MatchedPanels[panel-16]=1;
                           if(P1StackFlags[panel-16] & FLAG_CHAINING)
                              ischain=1;
                           combosize++;
                        }
                     }
                  }
               }
               else // not the same, but matchable
                  count=1;
            }
         }
         else count=0;
         oldpanel=P1StackPanels[panel];
         panel+=8;
      }
   }

                                                 // check horizontal matches
   count=0;
   panel=0;
   for(row=0;row<bottomrow+1;row++)
   {
      oldpanel=0;
      panel=row<<3;
      for(col=0;col<6;col++)
      {
         something=P1StackFlags[panel] & EXCLUDE_MATCH;
         if(P1StackPanels[panel] && !something)
         {
            if(!count) count=1;
            else
            {
               if(P1StackPanels[panel]==oldpanel)
               {
                  count++;
                  if(count>2)
                  {
                     if(!MatchedPanels[panel])
                     {
                        MatchedPanels[panel]=1;
                        if(P1StackFlags[panel] & FLAG_CHAINING)
                           ischain=1;
                        combosize++;
                     }
                     if(count==3)
                     {
                        if(!MatchedPanels[panel-1])
                        {
                           MatchedPanels[panel-1]=1;
                           if(P1StackFlags[panel-1] & FLAG_CHAINING)
                              ischain=1;
                           combosize++;
                        }
                        if(!MatchedPanels[panel-2])
                        {
                           MatchedPanels[panel-2]=1;
                           if(P1StackFlags[panel-2] & FLAG_CHAINING)
                              ischain=1;
                           combosize++;
                        }
                     }
                  }
               }
               else // not the same, but matchable
                  count=1;
            }
         }
         else count=0;
         oldpanel=P1StackPanels[panel];
         panel++;
      }
   }

if(ischain)
{
   if(P1ChainCounter) P1ChainCounter++;
   else P1ChainCounter=2;
}

comboindex=combosize;
for(row=bottomrow;row>=0;row--)
{
   panel=row<<3+5;
   for(col=5;col>=0;col--)
   {
      if(MatchedPanels[panel])
      {
         if(P1StackFlags[panel] & FLAG_LANDING)
            P1StackFlags[panel]-=FLAG_LANDING;
         P1StackFlags[panel]+=FLAG_MATCHED;
         P1StackTimers[panel]=FRAMECOUNT_MATCH;
         if(ischain)
         {
            if(!(P1StackFlags[panel] & FLAG_CHAINING))
            {
               P1StackFlags[panel] += FLAG_CHAINING;
               Count_ChainPanels++;
            }
         }
         something=combosize<<7;
         whatever=P1ChainCounter<<14;
         P1StackTags[panel]= whatever | something | comboindex;
         comboindex--;
         if(!comboindex)
         {
            firstpanelcol=col;
            firstpanelrow=row;
         }
      }
      else
      {
         if(P1StackPanels[panel])
         {
               // if a panel wasn't matched but was eligible,
               // we might have to remove its chain flag...!
            something=P1StackFlags[panel]&EXCLUDE_MATCH;
            if(!something)
            {
               if(row!=bottomrow)
               {
                  something=P1StackFlags[panel+8] & FLAG_SWAPPING;
                  if(!something)   
                  {     // no swapping panel below
                        // so this panel loses its chain flag
                     if(P1StackFlags[panel] & FLAG_CHAINING)
                     {
                        P1StackFlags[panel]-=FLAG_CHAINING;
                        Count_ChainPanels--;
                     }
                  }
               }
               else  // a panel landed on the bottom row, so it surely
               {     // loses its chain flag.
                  if(P1StackFlags[panel] & FLAG_CHAINING)
                  {
                     P1StackFlags[panel]-=FLAG_CHAINING;
                     Count_ChainPanels--;
                  }
               }
            }
         }
      }
      panel--;
   }
}

if(combosize)
{
   if(combosize>3)
   {
      Switch(ScoreMode)
      {
         Case SCOREMODE_TA:
            if(combosize>30) combosize=30;
            P1Score+=Score_Combo_TA[combosize];

         Case SCOREMODE_PDP64:
            if(combosize<41) P1Score+=Score_Combo_PdP64[combosize];
            else P1Score+=20400+((combosize-40)*800);
      }

      EnqueueComboCard(firstpanelcol,firstpanelrow,combosize<<4);
      EnqueueConfetti(firstpanelcol<<4+P1StackPosX+4,
                      firstpanelrow<<4+P1StackPosY+P1StackDisplacement-9);
      firstpanelrow--; // offset chain cards
   }

   if(ischain)
   {
      something=P1ChainCounter;
      if(ScoreMode==SCOREMODE_TA)
      {
            if(P1ChainCounter>13) something=0;
      }

      EnqueueChainCard(firstpanelcol,firstpanelrow,something);
      EnqueueConfetti(firstpanelcol<<4+P1StackPosX+4,
                      firstpanelrow<<4+P1StackPosY+P1StackDisplacement-9);
   }

   something=P1ChainCounter;
   Switch(ScoreMode)
   {
      Case SCOREMODE_TA:
         if(P1ChainCounter>13) something=0;
         P1Score+=Score_Chain_TA[something];
   }

   if(combosize>3 || ischain)
   {
      if(P1StopTime) P1StopTime++;
      else
      {
         if(ischain) P1StopTime+=StopTime_Chain[PanelsInTopRow][P1DifficultyLV];
         else P1StopTime+= StopTime_Combo[PanelsInTopRow][P1DifficultyLV];

         MrStopState=1;
         MrStopTimer=MrStopAni[P1StopTime];
         P1StopTimeTimer=60;
      }
      if(P1StopTime>99) P1StopTime=99;

      SFX_Buddy_Play=P1Stage;
      SFX_Land_Play=0;
   }

   P1ManualRaise=0;
   P1ScoreRender=1;
}

}



void SetHoverers(int firsthoverer, int hovertime, int addflags)
{
   int hoverstime, panel, break, something, nonpanel;
   panel=firsthoverer;
   if(firsthoverer<0) break++;
   hoverstime=hovertime;
   while(!break)
   {
      nonpanel=0;
      if(!P1StackPanels[panel]) nonpanel++;
      something=P1StackFlags[panel] & EXCLUDE_HOVER;
      if(nonpanel || something) break++;
      else
      {
         if(!(P1StackFlags[panel] & FLAG_SWAPPING))
            {}
         else hoverstime+=P1StackTimers[panel];
         something=P1StackFlags[panel] & FLAG_CHAINING;
         P1StackFlags[panel]=FLAG_HOVERING | addflags | something;
         P1StackTimers[panel]=hoverstime;
         if(!something)
           if(addflags & FLAG_CHAINING) Count_ChainPanels++;
      }
      panel-=8;
      if(panel<0) break++;
   }
}

void SetHoverers2(int firsthoverer, int hovertime, int addflags)
{
   // this version of the SetHoverers routine is for use during Phase 1&2,
   // when panels above the first should be given an extra tick of hover time.
   // This is because their timers will be decremented once on the same tick
   // they are set, as Phase 1&2 iterates backward through the stack.

   int notfirst;   // if set, the current panel isn't the first one
   int hoverstime, panel, break, something, nonpanel;
   panel=firsthoverer;
   if(firsthoverer<0) break++;
   hoverstime=hovertime;
   while(!break)
   {
      nonpanel=0;
      if(!P1StackPanels[panel]) nonpanel++;
      something=P1StackFlags[panel] & EXCLUDE_HOVER;
      if(nonpanel || something) break++;
      else
      {
         if(!(P1StackFlags[panel] & FLAG_SWAPPING))
            {}
         else hoverstime+=P1StackTimers[panel];
         something=P1StackFlags[panel] & FLAG_CHAINING;
         P1StackFlags[panel]=FLAG_HOVERING | addflags | something;
         P1StackTimers[panel]=hoverstime+notfirst;
         if(!something)
           if(addflags & FLAG_CHAINING) Count_ChainPanels++;
         notfirst=1;
      }
      panel-=8;
      if(panel<0) break++;
   }
}


void NewRow()
{
   int panel;
   int something, somethingelse, anotherthing, whatever;
   int break;

                     // move cursor up
                  if(P1CurRow) P1CurRow--;

                     // move panels up
                  for(panel=0;panel<86;panel++)
                  {
                     P1StackPanels[panel]=P1StackPanels[panel+8];
                     P1StackFlags[panel]=P1StackFlags[panel+8];
                     P1StackTimers[panel]=P1StackTimers[panel+8];
                     P1StackTags[panel]=P1StackTags[panel+8];
                  }

                     // put bottom row into play
                  for(panel=80;panel<88;panel++)
                     if(P1StackFlags[panel] & FLAG_DIMMED)
                        P1StackFlags[panel]-=FLAG_DIMMED;                  
 
                     // generate a new row
                  for(panel=88;panel<90;panel++)
                  {
                     break=0;
                     while(!break)
                     {
                        P1StackPanels[panel]=random(1,6);
                        break=1;
                        if(P1StackPanels[panel]==P1StackPanels[panel-8])
                           break=0;
                     }

                     P1StackFlags[panel]=FLAG_DIMMED;
                     P1StackTimers[panel]=0;
                  }
                  for(panel=90;panel<94;panel++)
                  {
                     whatever=0;
                     if(P1StackPanels[panel-1]==P1StackPanels[panel-2])
                        whatever=1;
                     break=0;
                     while(!break)
                     {
                        P1StackPanels[panel]=random(1,6);
                        something=0;
                        if(whatever)
                        {  if(P1StackPanels[panel]==P1StackPanels[panel-1])
                              something=1;
                        }
                        somethingelse=0;
                        if(P1StackPanels[panel]==P1StackPanels[panel-8])
                           somethingelse=1;
                        break=1;
                        if(something || somethingelse) break=0;
                     }

                     P1StackFlags[panel]=FLAG_DIMMED;
                     P1StackTimers[panel]=0;
                  }
                  P1StackDisplacement=16;
                  bottomrow=10;                  

                  DoMatchesCheck=1;
}



void QuietCursorMovement()
{
   int something, whatever;

   if(P1CurTimer)
   {     // the cursor will move if a direction's was just pressed or has been
         // pressed for at least the P1CurWaitTime
      P1CurMoveAloud=0;
      something=0; whatever=0;
      if(P1CurTimer==1) something=1;
      if(P1CurTimer==P1CurWaitTime) whatever=1;
      if(something || whatever)
      {
         if(P1CurDir==DIR_UP)
         {  if(P1CurRow>0) P1CurRow--;
         } else
         {  if(P1CurDir==DIR_DOWN)
            {  if(P1CurRow<bottomrow) P1CurRow++;
            } else
            {  if(P1CurDir==DIR_LEFT)
               {  if(P1CurCol>0) P1CurCol--;
               } else
               { if(P1CurDir==DIR_RIGHT)
                 {  if(P1CurCol<4) P1CurCol++;
                 }
               }
            }
         }
      }
      if(!whatever) P1CurTimer++;      
   }
}

